import type { GetOutputFile } from 'bundle-require';
import type { Request, RequestHandler } from 'express';
import type { MockMethod, MockOptions, Recordable, RespThisType } from './types';
import fs from 'node:fs';
import path from 'node:path';
import { URL } from 'node:url';
import { bundleRequire, JS_EXT_RE } from 'bundle-require';
import chokidar from 'chokidar';
import fg from 'fast-glob';
import { match, pathToRegexp } from 'path-to-regexp';
import colors from 'picocolors';
import { isArray, isFunction, isRegExp, sleep } from './utils';

let mockData: MockMethod[] = [];

export async function createMockServer(opts: MockOptions) {
  if (mockData.length > 0) {
    return;
  }
  mockData = await getMockData(opts);
  return createWatch(opts);
}

export function createMiddleware(opts: MockOptions) {
  const middleware: RequestHandler = async (req, res, next) => {
    const { logger } = opts;

    if (!opts.enable || req.url === '/') {
      next();
      return;
    }

    let queryParams: {
      query?: {
        [key: string]: any;
      };
      pathname?: string | null;
    } = {};

    if (req.url) {
      queryParams = new URL(req.url, 'http://localhost');
    }

    const reqUrl = queryParams.pathname;

    const matchRequest = mockData.find((item) => {
      if (!reqUrl || !item || !item.url) {
        return false;
      }
      if (item.method && item.method.toUpperCase() !== req.method) {
        return false;
      }
      return pathToRegexp(item.url).test(reqUrl);
    });

    if (matchRequest) {
      const isGet = req.method && req.method.toUpperCase() === 'GET';
      const { response, rawResponse, timeout, statusCode, url } = matchRequest;

      const reqStartTime = Date.now();

      if (timeout) {
        await sleep(timeout);
      }

      const urlMatch = match(url, { decode: decodeURIComponent });

      let query = queryParams.query as any;
      if (reqUrl) {
        if ((isGet && JSON.stringify(query) === '{}') || !isGet) {
          const params = (urlMatch(reqUrl) as any).params;
          if (JSON.stringify(params) !== '{}') {
            query = (urlMatch(reqUrl) as any).params || {};
          }
          else {
            query = queryParams.query || {};
          }
        }
      }

      const self: RespThisType = { req, res, parseJson: parseJson.bind(null, req) };
      if (isFunction(rawResponse)) {
        await rawResponse.bind(self)(req, res);
      }
      else {
        const body = await parseJson(req);
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Access-Control-Allow-Credentials', 'true');
        res.setHeader('Access-Control-Allow-Origin', req.headers.origin || '*');
        res.statusCode = statusCode || 200;
        const mockResponse = isFunction(response)
          ? response.bind(self)({ url: req.url as any, body, query, headers: req.headers })
          : response;
        res.end(JSON.stringify(mockResponse));
      }

      if (logger) {
        const status = res.statusCode;
        const isOk = status && status >= 200 && status < 300;
        const sCode = (isOk) ? colors.green(status) : colors.yellow(status);
        const time = `${Date.now() - reqStartTime}ms`;
        const msg = `${colors.blue(req.method)} ${req.url} ${sCode} ${colors.dim(time)}`;
        isOk ? logInfo(msg) : logError(msg);
      }
      return;
    }

    next();
  };

  return middleware;
}

// create watch mock
function createWatch(opt: MockOptions) {
  const { mockPath, logger, watch } = opt;

  if (!watch || !mockPath || !fs.existsSync(mockPath)) {
    return;
  }

  const watcher = chokidar.watch(mockPath, {
    ignoreInitial: true,
    // ignore files generated by `bundle require`
    ignored: '**/_*.bundled_*.(mjs|cjs)',
  });

  watcher.on('all', async (event, file) => {
    logger && loggerOutput(`mock file ${event}`, file);
    mockData = await getMockData(opt);
  });
}

// clear cache

function parseJson(req: Request): Promise<Recordable> {
  return new Promise((resolve) => {
    let jsonStr: Recordable = {};
    let str = '';
    req.on('data', (chunk) => {
      str += chunk;
    });
    req.on('end', () => {
      try {
        // json
        jsonStr = JSON.parse(str);
      }
      catch {
        // x-www-form-urlencoded
        const params = new URLSearchParams(str);
        const body: Recordable = {};
        params.forEach((value, key) => {
          body[key] = value;
        });
        jsonStr = body;
      }
      resolve(jsonStr);
    });
  });
}

// load mock .ts files and watch
async function getMockData(opt: MockOptions) {
  const { mockPath, ignore } = opt;

  if (!mockPath || !fs.existsSync(mockPath)) {
    return [];
  }

  let ret: MockMethod[] = [];

  const mockFiles = fg
    .sync(`**/*.{ts,mjs,js}`, {
      cwd: mockPath,
    })
    .filter((item) => {
      if (!ignore) {
        return true;
      }
      if (isFunction(ignore)) {
        return !ignore(item);
      }
      if (isRegExp(ignore)) {
        return !ignore.test(path.basename(item));
      }
      return true;
    });

  try {
    ret = [];
    const resolveModulePromiseList: any[] = [];

    for (let index = 0; index < mockFiles.length; index++) {
      const mockFile = mockFiles[index];
      resolveModulePromiseList.push(resolveModule(path.join(mockPath, mockFile)));
    }

    const loadAllResult = await Promise.all(resolveModulePromiseList);
    for (const resultModule of loadAllResult) {
      let mod = resultModule;
      if (!isArray(mod)) {
        mod = [mod];
      }
      ret = [...ret, ...mod];
    }
  }
  catch (error: any) {
    loggerOutput(`mock reload error`, error);
    ret = [];
  }
  return ret;
}

// fixed file generation format
// use a random path to avoid import cache
const getOutputFile: GetOutputFile = (filepath, format) => {
  const dirname = path.dirname(filepath);
  const basename = path.basename(filepath);
  const randomname = `${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
  return path.resolve(
    dirname,
    `_${basename.replace(JS_EXT_RE, `.bundled_${randomname}.${format === 'esm' ? 'mjs' : 'cjs'}`)}`,
  );
};

// Inspired by vite
// support mock .ts files
async function resolveModule(p: string): Promise<any> {
  const mockData = await bundleRequire({
    filepath: p,
    getOutputFile,
  });

  let mod = mockData.mod.default || mockData.mod;
  if (isFunction(mod)) {
    mod = await mod({});
  }
  return mod;
}

function getTag(isError = false) {
  return !isError ? colors.cyan(`[tomjs:mock]`) : colors.red(`[tomjs:mock]`);
}

function logInfo(...args: any[]) {
  return console.log(colors.dim(new Date().toLocaleTimeString()), getTag(), ...args);
}

function logError(...args: any[]) {
  return console.log(colors.dim(new Date().toLocaleTimeString()), getTag(true), ...args);
}

function loggerOutput(title: string, msg?: string | number, type: 'info' | 'error' = 'info') {
  return console.log(
    `${colors.dim(new Date().toLocaleTimeString())} ${getTag(type !== 'info')} ${colors.green(title)} ${colors.dim(
      msg ?? '',
    )}`,
  );
}
